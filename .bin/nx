#!/usr/bin/env bash

# Nexus CLI - Main management tool for the nexus repository
# Manages Docker stacks, configurations, and development environment

set -euo pipefail

# Colors for output
BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m' # No Color

# Directories - use realpath to avoid issues with subshells
SCRIPT_DIR="$(dirname "$(readlink -f "${BASH_SOURCE[0]}")")"
ROOT_DIR="$(dirname "$SCRIPT_DIR")"
STACKS_DIR="${ROOT_DIR}/stacks"
SCRIPTS_DIR="${ROOT_DIR}/scripts"

# Check if main compose file exists
has_compose() {
    [ -f "${ROOT_DIR}/compose.yaml" ]
}

# Get compose file path
get_compose_file() {
    if [ -f "${ROOT_DIR}/compose.yaml" ]; then
        echo "${ROOT_DIR}/compose.yaml"
    else
        return 1
    fi
}

# Print colored message
print_info() {
    echo -e "${BLUE}$1${NC}"
}

print_success() {
    echo -e "${GREEN}$1${NC}"
}

print_warning() {
    echo -e "${YELLOW}$1${NC}"
}

print_error() {
    echo -e "${RED}$1${NC}"
}

# Check if a command exists
command_exists() {
    command -v "$1" >/dev/null 2>&1
}

# Check prerequisites
check_prerequisites() {
    local missing=()
    local install_attempt="${1:-false}"

    print_info "Checking prerequisites..."

    # Check for direnv
    if ! command_exists direnv; then
        if [[ "$install_attempt" == "true" ]]; then
            print_warning "direnv not found. Attempting to install..."
            if command_exists brew; then
                brew install direnv
            elif command_exists apt-get; then
                sudo apt-get update && sudo apt-get install -y direnv
            else
                missing+=("direnv")
            fi
        else
            missing+=("direnv")
        fi
    fi

    # Check for docker
    if ! command_exists docker; then
        missing+=("docker")
    fi

    # Check for docker compose (v2 plugin or standalone)
    if ! docker compose version >/dev/null 2>&1 && ! command_exists docker-compose; then
        missing+=("docker-compose")
    fi

    # Check for git
    if ! command_exists git; then
        missing+=("git")
    fi

    # Check for python3 (needed for fmt command)
    if ! command_exists python3; then
        missing+=("python3")
    fi

    if [ ${#missing[@]} -eq 0 ]; then
        print_success "✓ All prerequisites are installed"

        # Check if direnv is hooked
        if command_exists direnv; then
            if ! grep -q "direnv hook" ~/.zshrc 2>/dev/null && ! grep -q "direnv hook" ~/.bashrc 2>/dev/null; then
                print_warning "⚠ direnv is installed but not hooked into your shell"
                echo ""
                echo "Add this to your ~/.zshrc or ~/.bashrc:"
                echo "  eval \"\$(direnv hook zsh)\"  # for zsh"
                echo "  eval \"\$(direnv hook bash)\" # for bash"
                echo ""
                echo "Then run: direnv allow ."
            fi
        fi

        return 0
    else
        print_error "✗ Missing prerequisites:"
        for dep in "${missing[@]}"; do
            echo "  - $dep"
        done

        if [[ "$install_attempt" == "false" ]]; then
            echo ""
            echo "Run 'nx check --install' to attempt automatic installation"
        fi

        return 1
    fi
}

# Setup function
setup() {
    print_info "Running Nexus setup..."

    if [ ! -f "${SCRIPTS_DIR}/setup.sh" ]; then
        print_error "Error: setup.sh not found"
        exit 1
    fi

    bash "${SCRIPTS_DIR}/setup.sh"
}

# Check environment files
# Container user/group mapping
# Format: service_name:uid:gid:description
# Add # nx:root-allowed comment in compose.yaml to exempt from root check
declare -A CONTAINER_UIDS=(
    ["excalidraw"]="101:101:nginx"
    ["omni-tools"]="101:101:nginx"
    ["homie"]="1000:1000:appuser"
    ["mytabs"]="1993:1993:deno"
    ["n8n"]="1000:1000:node"
    ["searxng"]="977:977:searxng"
)

# Fix directory permissions for containers
fix_permissions() {
    print_info "Fixing directory permissions..."

    # Source environment file
    if [ -f "${ROOT_DIR}/.env" ]; then
        set -a
        source "${ROOT_DIR}/.env"
        set +a
    fi

    local data_path="${DATA_PATH:-/mnt/data/docker}"
    local fixed=0

    # Iterate through all defined container UIDs
    for service in "${!CONTAINER_UIDS[@]}"; do
        IFS=':' read -r uid gid desc <<< "${CONTAINER_UIDS[$service]}"

        # Check if directory exists (try service name as directory)
        local dir="$data_path/$service"
        if [ -d "$dir" ]; then
            echo "  Fixing $service ($desc $uid:$gid)..."
            sudo chown -R "$uid:$gid" "$dir"
            ((fixed++))
        fi
    done

    if [ $fixed -gt 0 ]; then
        print_success "Fixed permissions for $fixed directories"
    else
        print_warning "No directories found to fix"
    fi
}

# Check if container user is defined
check_container_user() {
    local compose_file="$1"
    local service="$2"
    local warnings=0

    # Check if service is exempt from root check
    if grep -q "# nx:root-allowed" "$compose_file" 2>/dev/null; then
        return 0
    fi

    # Check if user is defined in compose
    local user_defined=$(docker compose -f "$compose_file" config 2>/dev/null | \
        yq eval ".services.$service.user // \"\"" -)

    # If user not defined in compose, check if we have a mapping
    if [ -z "$user_defined" ] || [ "$user_defined" = "null" ]; then
        if [ -n "${CONTAINER_UIDS[$service]:-}" ]; then
            IFS=':' read -r uid gid desc <<< "${CONTAINER_UIDS[$service]}"
            echo "    ℹ️  $service: using predefined $desc ($uid:$gid)"
        else
            print_warning "    ⚠️  $service: no user defined and no mapping found"
            ((warnings++))
        fi
    else
        echo "    ✓ $service: user defined as $user_defined"
    fi

    return $warnings
}

# Validate environment and security configuration
check() {
    # Temporarily disable exit on error for this function
    set +e

    print_info "=== Nexus Environment Check ==="
    echo ""

    local errors=0
    local warnings=0

    # Source environment file
    if [ -f "${ROOT_DIR}/.env" ]; then
        set -a
        source "${ROOT_DIR}/.env"
        set +a
    fi

    # 1. Check environment variable validation
    print_info "1. Validating environment variables..."
    local valid_stacks=()
    while IFS= read -r stack; do
        if [ -f "${STACKS_DIR}/${stack}/compose.yaml" ]; then
            echo "  Checking ${stack}..."
            local error_output
            if ! error_output=$(cd "${STACKS_DIR}/${stack}" && docker compose config 2>&1 >/dev/null); then
                print_error "  ✗ Error in ${stack}"
                # Show first line of error for context
                echo "     $(echo "$error_output" | head -1 | sed 's/^/     /')"
                ((warnings++))
            else
                echo "  ✓ ${stack} environment valid"
                valid_stacks+=("$stack")
            fi
        fi
    done < <(get_stacks)

    if [ -f "${ROOT_DIR}/compose.yaml" ]; then
        echo "  Checking root..."
        if ! (cd "${ROOT_DIR}" && docker compose config > /dev/null 2>&1); then
            print_error "  ✗ Error in root"
            ((warnings++))
        else
            echo "  ✓ Root environment valid"
        fi
    fi
    echo ""

    # 2. Check container users and security
    print_info "2. Checking container user configuration..."
    for stack in "${valid_stacks[@]}"; do
        local compose_file="${STACKS_DIR}/${stack}/compose.yaml"
        if [ -f "$compose_file" ]; then
            echo "  Stack: ${stack}"

            # Get all services from compose file
            local services=$(docker compose -f "$compose_file" config --services 2>/dev/null)
            while IFS= read -r service; do
                if [ -n "$service" ]; then
                    check_container_user "$compose_file" "$service" || true
                    local result=$?
                    warnings=$((warnings + result))
                fi
            done <<< "$services"
        fi
    done
    echo ""

    # 3. Check and fix directory permissions
    print_info "3. Checking directory permissions..."
    fix_permissions || true
    echo ""

    # Summary
    echo ""
    print_info "=== Check Summary ==="

    # Re-enable exit on error
    set -e

    if [ $errors -eq 0 ] && [ $warnings -eq 0 ]; then
        print_success "✓ All checks passed!"
        return 0
    elif [ $errors -eq 0 ]; then
        print_warning "⚠ Checks completed with $warnings warning(s)"
        return 0
    else
        print_error "✗ Found $errors error(s) and $warnings warning(s)"
        return 1
    fi
}

# List all services (replaces list_stacks for consolidated compose)
list_stacks() {
    local verbose="${1:-false}"

    if ! has_compose; then
        print_error "No compose.yaml found in ${ROOT_DIR}"
        return 1
    fi

    local compose_file="${ROOT_DIR}/compose.yaml"
    local total_services=$(docker compose -f "$compose_file" config --services 2>/dev/null | wc -l)
    local running_services=$(docker compose ps --status running 2>/dev/null | tail -n +2 | wc -l)

    if [ "$verbose" = "true" ]; then
        print_info "Nexus Stack Overview:"
        echo ""
        printf "%-20s %s\n" "Compose File:" "compose.yaml"
        printf "%-20s %s\n" "Total Services:" "$total_services"
        printf "%-20s %s\n" "Running Services:" "$running_services"
        echo ""
        echo "Use 'nx services' to see all services with their status"
    else
        print_info "Nexus Stack: $total_services services ($running_services running)"
        echo ""
        echo "Use 'nx list -v' for details or 'nx services' to see all services"
    fi
}

# List all services with their status
list_services() {
    local filter="${1:-}"
    local group_by_stack=false

    # Check for --stacks flag
    if [[ "${1:-}" == "--stacks" ]]; then
        group_by_stack=true
        filter="${2:-}"
    fi

    if ! has_compose; then
        print_error "No compose.yaml found in ${ROOT_DIR}"
        return 1
    fi

    local compose_file="${ROOT_DIR}/compose.yaml"

    print_info "Services:"
    echo ""
    printf "%-25s %-12s %-10s %s\n" "SERVICE" "STATE" "HEALTH" "STATUS"
    printf "%.80s\n" "--------------------------------------------------------------------------------"

    # Get all defined services
    local services=$(docker compose -f "$compose_file" config --services 2>/dev/null | sort)

    if [ "$group_by_stack" = true ]; then
        # Group by stack - get homepage.group labels from docker compose config
        local -A service_stacks
        local -A stacks_seen

        # Get full config once for efficiency
        local full_config=$(docker compose -f "$compose_file" config 2>/dev/null)

        while IFS= read -r service; do
            if [ -z "$service" ]; then
                continue
            fi

            # Extract homepage.group label for this service
            local stack_label=$(echo "$full_config" | \
                awk -v svc="$service" '
                    /^  [a-z]/ { current_service = $1; sub(/:$/, "", current_service) }
                    current_service == svc && /homepage\.group:/ {
                        sub(/.*homepage\.group: */, "")
                        gsub(/["'\'']/, "")
                        print
                        exit
                    }
                ')

            if [ -z "$stack_label" ]; then
                stack_label="Uncategorized"
            fi

            service_stacks["$service"]="$stack_label"
            stacks_seen["$stack_label"]=1
        done <<< "$services"

        # Sort stacks alphabetically
        local sorted_stacks=$(printf '%s\n' "${!stacks_seen[@]}" | sort)

        # Print services grouped by stack
        while IFS= read -r stack_name; do
            [ -z "$stack_name" ] && continue

            echo ""
            echo -e "${BLUE}${stack_name}${NC}"

            while IFS= read -r service; do
                [ -z "$service" ] && continue

                if [ "${service_stacks[$service]}" != "$stack_name" ]; then
                    continue
                fi

                # Apply filter if provided
                if [ -n "$filter" ] && ! echo "$service" | grep -qi "$filter"; then
                    continue
                fi

                print_service_status "$service"
            done <<< "$services"
        done <<< "$sorted_stacks"
    else
        # Simple alphabetical list
        while IFS= read -r service; do
            if [ -z "$service" ]; then
                continue
            fi

            # Apply filter if provided
            if [ -n "$filter" ] && ! echo "$service" | grep -qi "$filter"; then
                continue
            fi

            print_service_status "$service"
        done <<< "$services"
    fi

    echo ""
    echo "Total: $(echo "$services" | grep -v '^$' | wc -l) services"
}

# Helper function to print service status
print_service_status() {
    local service="$1"
    local state="not created"
    local health="-"
    local status="-"

    # Try to find the container
    local container_info=$(docker ps -a --filter "name=^${service}$" --format "{{.State}}|{{.Status}}" 2>/dev/null | head -1)

    if [ -n "$container_info" ]; then
        state=$(echo "$container_info" | cut -d'|' -f1)
        status=$(echo "$container_info" | cut -d'|' -f2)

        # Extract health status
        if echo "$status" | grep -q "(healthy)"; then
            health="healthy"
        elif echo "$status" | grep -q "(unhealthy)"; then
            health="unhealthy"
        elif echo "$status" | grep -q "health: starting"; then
            health="starting"
        fi

        # Simplify status
        if [ "$state" = "running" ]; then
            # Extract uptime
            if echo "$status" | grep -qE "Up [0-9]+ (second|minute|hour|day|week)"; then
                status=$(echo "$status" | sed -E 's/Up ([0-9]+ [a-z]+).*/\1/' | sed 's/seconds/s/' | sed 's/minutes/m/' | sed 's/hours/h/' | sed 's/days/d/' | sed 's/weeks/w/')
            else
                status="running"
            fi
        elif [ "$state" = "exited" ]; then
            status=$(echo "$status" | sed -E 's/Exited \(([0-9]+)\).*/exit \1/')
        fi
    fi

    # Color coding
    local state_color="${RED}"
    if [ "$state" = "running" ]; then
        state_color="${GREEN}"
    elif [ "$state" = "restarting" ]; then
        state_color="${YELLOW}"
    fi

    local health_color="${NC}"
    if [ "$health" = "healthy" ]; then
        health_color="${GREEN}"
    elif [ "$health" = "unhealthy" ]; then
        health_color="${RED}"
    elif [ "$health" = "starting" ]; then
        health_color="${YELLOW}"
    fi

    printf "%-25s ${state_color}%-12s${NC} ${health_color}%-10s${NC} %s\n" \
        "$service" "$state" "$health" "$status"
}

# Interactive mode to toggle services
interactive_mode() {
    local filter="${1:-}"

    if ! has_compose; then
        print_error "No compose.yaml found in ${ROOT_DIR}"
        return 1
    fi

    # Check for required tools
    if ! command_exists fzf 2>/dev/null; then
        print_warning "Interactive mode requires 'fzf' for best experience"
        print_info "Falling back to basic interactive mode..."
        interactive_mode_basic "$filter"
        return
    fi

    local compose_file="${ROOT_DIR}/compose.yaml"

    while true; do
        # Collect services and their states
        local service_list=()
        local services_raw=$(docker compose -f "$compose_file" config --services 2>/dev/null)

        while IFS= read -r service; do
            if [ -z "$service" ]; then
                continue
            fi

            # Apply filter if provided
            if [ -n "$filter" ] && ! echo "$service" | grep -qi "$filter"; then
                continue
            fi

            # Get state
            local state=$(docker ps -a --filter "name=^${service}$" --format "{{.State}}" 2>/dev/null | head -1)
            if [ -z "$state" ]; then
                state="not-created"
            fi

            local display_state="○"
            if [ "$state" = "running" ]; then
                display_state="●"
            fi

            service_list+=("${display_state} ${service}|${service}|${state}")
        done <<< "$services_raw"

        if [ ${#service_list[@]} -eq 0 ]; then
            print_error "No services found"
            return 1
        fi

        if [ ${#service_list[@]} -eq 0 ]; then
            print_error "No services found"
            return 1
        fi

        # Show interactive selection
        clear
        echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
        echo -e "${BLUE}  Nexus Service Manager - Interactive Mode${NC}"
        echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
        echo ""
        echo "● = Running  ○ = Stopped"
        echo ""
        echo "Select service to toggle (ESC/Ctrl+C to exit):"
        echo ""

        local selected=$(printf '%s\n' "${service_list[@]}" | \
            awk -F'|' '{print $1}' | \
            fzf --height=40% --reverse --border \
                --prompt="Toggle service > " \
                --header="Press ENTER to toggle, ESC to exit" \
                --color=dark \
                --color=fg:-1,bg:-1,hl:#5fff87,fg+:-1,bg+:-1,hl+:#ffaf5f \
                --color=info:#af87ff,prompt:#5fff87,pointer:#ff87d7,marker:#ff87d7,spinner:#ff87d7)

        if [ -z "$selected" ]; then
            clear
            echo ""
            print_info "Exiting interactive mode"
            return 0
        fi

        # Extract service from selection
        local service_info=$(printf '%s\n' "${service_list[@]}" | grep "^${selected}|")
        local service=$(echo "$service_info" | cut -d'|' -f2)
        local current_state=$(echo "$service_info" | cut -d'|' -f3)

        # Determine action
        local action="start"
        local action_display="Start"
        if [ "$current_state" = "running" ]; then
            action="stop"
            action_display="Stop"
        fi

        # Confirm action
        clear
        echo ""
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "  Service: ${GREEN}${service}${NC}"
        echo -e "  Action:  ${YELLOW}${action_display}${NC}"
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        read -p "Confirm action? [y/N] " -n 1 -r
        echo ""

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo ""
            print_info "Executing: docker compose ${action} ${service}"
            cd "${ROOT_DIR}"

            if [ "$action" = "start" ]; then
                docker compose up -d "$service"
            else
                docker compose stop "$service"
            fi

            echo ""
            print_success "Action completed"
            echo ""
            read -p "Press ENTER to continue..."
        else
            echo ""
            print_info "Action cancelled"
            echo ""
            read -p "Press ENTER to continue..."
        fi
    done
}

# Basic interactive mode without fzf
interactive_mode_basic() {
    local filter="${1:-}"

    if ! has_compose; then
        print_error "No compose.yaml found in ${ROOT_DIR}"
        return 1
    fi

    local compose_file="${ROOT_DIR}/compose.yaml"

    while true; do

        clear
        echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
        echo -e "${BLUE}  Nexus Service Manager - Interactive Mode${NC}"
        echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
        echo ""

        local service_list=()
        local index=1
        local services_raw=$(docker compose -f "$compose_file" config --services 2>/dev/null)

        while IFS= read -r service; do
            if [ -z "$service" ]; then
                continue
            fi

            # Apply filter if provided
            if [ -n "$filter" ] && ! echo "$service" | grep -qi "$filter"; then
                continue
            fi

            local state=$(docker ps -a --filter "name=^${service}$" --format "{{.State}}" 2>/dev/null | head -1)
            if [ -z "$state" ]; then
                state="not-created"
            fi

            local display_state="${RED}○ stopped${NC}"
            if [ "$state" = "running" ]; then
                display_state="${GREEN}● running${NC}"
            fi

            printf "%2d) %-30s %b\n" "$index" "$service" "$display_state"
            service_list+=("${service}|${state}")
            ((index++))
        done <<< "$services_raw"

        echo ""
        echo "Enter service number to toggle (0 to exit):"
        read -p "> " selection

        if [ "$selection" = "0" ] || [ -z "$selection" ]; then
            clear
            echo ""
            print_info "Exiting interactive mode"
            return 0
        fi

        # Validate selection
        if ! [[ "$selection" =~ ^[0-9]+$ ]] || [ "$selection" -lt 1 ] || [ "$selection" -ge "$index" ]; then
            echo ""
            print_error "Invalid selection"
            sleep 2
            continue
        fi

        # Get selected service
        local service_info="${service_list[$((selection-1))]}"
        local service=$(echo "$service_info" | cut -d'|' -f1)
        local current_state=$(echo "$service_info" | cut -d'|' -f2)

        # Determine action
        local action="start"
        local action_display="Start"
        if [ "$current_state" = "running" ]; then
            action="stop"
            action_display="Stop"
        fi

        # Confirm action
        echo ""
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo -e "  Service: ${GREEN}${service}${NC}"
        echo -e "  Action:  ${YELLOW}${action_display}${NC}"
        echo -e "${YELLOW}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
        echo ""
        read -p "Confirm action? [y/N] " -n 1 -r
        echo ""

        if [[ $REPLY =~ ^[Yy]$ ]]; then
            echo ""
            print_info "Executing: docker compose ${action} ${service}"
            cd "${ROOT_DIR}"

            if [ "$action" = "start" ]; then
                docker compose up -d "$service"
            else
                docker compose stop "$service"
            fi

            echo ""
            print_success "Action completed"
            echo ""
            read -p "Press ENTER to continue..."
        else
            echo ""
            print_info "Action cancelled"
            sleep 1
        fi
    done
}

# Start stacks
start_stacks() {
    local stack="${1:-}"

    if [ -n "$stack" ]; then
        print_info "Starting ${stack} stack..."
        if [ "$stack" = "root" ]; then
            cd "${ROOT_DIR}" && docker compose up -d
        else
            if [ -d "${STACKS_DIR}/${stack}" ]; then
                cd "${STACKS_DIR}/${stack}" && docker compose up -d
            else
                print_error "Stack '${stack}' not found"
                return 1
            fi
        fi
    else
        print_info "Starting all stacks..."

        if [ -f "${ROOT_DIR}/compose.yaml" ]; then
            cd "${ROOT_DIR}" && docker compose up -d
        fi

        while IFS= read -r stack; do
            if [ -f "${STACKS_DIR}/${stack}/compose.yaml" ]; then
                echo "Starting ${stack}..."
                cd "${STACKS_DIR}/${stack}" && docker compose up -d
            fi
        done < <(get_stacks)
    fi

    print_success "Started successfully"
}

# Stop stacks
stop_stacks() {
    local stack="${1:-}"

    if [ -n "$stack" ]; then
        print_info "Stopping ${stack} stack..."
        if [ "$stack" = "root" ]; then
            cd "${ROOT_DIR}" && docker compose down
        else
            if [ -d "${STACKS_DIR}/${stack}" ]; then
                cd "${STACKS_DIR}/${stack}" && docker compose down
            else
                print_error "Stack '${stack}' not found"
                return 1
            fi
        fi
    else
        print_info "Stopping all stacks..."

        while IFS= read -r stack; do
            if [ -f "${STACKS_DIR}/${stack}/compose.yaml" ]; then
                echo "Stopping ${stack}..."
                cd "${STACKS_DIR}/${stack}" && docker compose down
            fi
        done < <(get_stacks)

        if [ -f "${ROOT_DIR}/compose.yaml" ]; then
            cd "${ROOT_DIR}" && docker compose down
        fi
    fi

    print_success "Stopped successfully"
}

# Restart stacks
restart_stacks() {
    local stack="${1:-}"

    if [ -n "$stack" ]; then
        print_info "Restarting ${stack} stack..."
        if [ "$stack" = "root" ]; then
            cd "${ROOT_DIR}" && docker compose restart
        else
            if [ -d "${STACKS_DIR}/${stack}" ]; then
                cd "${STACKS_DIR}/${stack}" && docker compose restart
            else
                print_error "Stack '${stack}' not found"
                return 1
            fi
        fi
    else
        print_info "Restarting all stacks..."

        if [ -f "${ROOT_DIR}/compose.yaml" ]; then
            cd "${ROOT_DIR}" && docker compose restart
        fi

        while IFS= read -r stack; do
            if [ -f "${STACKS_DIR}/${stack}/compose.yaml" ]; then
                echo "Restarting ${stack}..."
                cd "${STACKS_DIR}/${stack}" && docker compose restart
            fi
        done < <(get_stacks)
    fi

    print_success "Restarted successfully"
}

# Show status with colored output
# Args: $1 = stack filter (optional), $2 = compact mode for watch (true/false)
show_status() {
    local stack_filter="${1:-}"
    local compact="${2:-false}"

    local filter_arg=""
    if [ -n "$stack_filter" ]; then
        filter_arg="--filter label=com.docker.compose.project=${stack_filter}"
    fi

    # Different format strings for compact vs normal mode
    local format_str
    if [ "$compact" = "true" ]; then
        # Compact: name, state, health, uptime (fits ~60 chars)
        format_str='{{.Names}}|{{.Status}}|{{.State}}'
    else
        # Normal: add ports and image
        format_str='{{.Names}}|{{.Status}}|{{.State}}|{{.Ports}}|{{.Image}}'
    fi

    docker ps -a $filter_arg --format "$format_str" \
        | sort -t"|" -k1,1 \
        | awk -F"|" -v compact="$compact" '
        BEGIN {
            # Colors
            green = "\033[32m"
            red = "\033[31m"
            yellow = "\033[33m"
            cyan = "\033[36m"
            dim = "\033[2m"
            reset = "\033[0m"

            # Print header
            if (compact == "true") {
                printf "%s%-18s %-4s %-2s %-4s%s\n", dim, "NAME", "STAT", "HC", "UP", reset
            } else {
                printf "%s%-18s %-4s %-2s %-4s %-12s %s%s\n", dim, "NAME", "STAT", "HC", "UP", "PORTS", "IMAGE", reset
            }
        }
        {
            name = $1
            status = $2
            state = $3

            # Truncate name if too long
            if (length(name) > 18) name = substr(name, 1, 15) "..."

            # Container state color and display
            if (state == "running") {
                ccolor = green
                state_display = "Up"
            } else if (state == "restarting") {
                ccolor = yellow
                state_display = "Rstr"
            } else {
                ccolor = red
                state_display = "Down"
            }

            # Extract health from status
            health = ""
            if (match(status, /\(healthy\)/))    health = "ok"
            else if (match(status, /\(unhealthy\)/)) health = "!!"
            else if (match(status, /\(health: starting\)/)) health = ".."
            hcolor = (health == "ok") ? green : (health == "!!" ? red : yellow)

            # Extract uptime (e.g., "Up 2 days" -> "2d", "Up 3 hours" -> "3h")
            uptime = ""
            if (match(status, /Up ([0-9]+) seconds?/, m)) uptime = m[1] "s"
            else if (match(status, /Up ([0-9]+) minutes?/, m)) uptime = m[1] "m"
            else if (match(status, /Up ([0-9]+) hours?/, m)) uptime = m[1] "h"
            else if (match(status, /Up ([0-9]+) days?/, m)) uptime = m[1] "d"
            else if (match(status, /Up ([0-9]+) weeks?/, m)) uptime = m[1] "w"
            else if (match(status, /Up About/, m)) uptime = "~1h"
            else if (state != "running") uptime = "-"

            if (compact == "true") {
                # Compact output: NAME STATE HEALTH UPTIME (~50 chars)
                # Pad name manually to handle ANSI colors correctly
                padded_name = sprintf("%-18s", name)
                printf "%s%s%s %-4s %s%-2s%s %-4s\n",
                    ccolor, padded_name, reset,
                    state_display,
                    hcolor, health, reset,
                    uptime
            } else {
                # Normal output: add ports and image
                ports = $4
                image = $5

                # Parse ports - extract just host:container mappings
                port_display = ""
                n = split(ports, port_arr, ", ")
                for (i = 1; i <= n && i <= 2; i++) {
                    p = port_arr[i]
                    # Match "0.0.0.0:8080->80/tcp" or ":::8080->80/tcp"
                    if (match(p, /[0-9]+->([0-9]+)/, pm)) {
                        if (port_display != "") port_display = port_display ","
                        # Extract host port
                        if (match(p, /:([0-9]+)->/, hp)) {
                            port_display = port_display hp[1]
                        }
                    }
                }
                if (n > 2) port_display = port_display "+"
                if (port_display == "") port_display = "-"

                # Truncate image name
                sub(/^.*\//, "", image)  # Remove registry prefix
                if (match(image, /:(.+)$/, tag)) {
                    img_name = substr(image, 1, RSTART-1)
                    img_tag = tag[1]
                    if (length(img_name) > 12) img_name = substr(img_name, 1, 10) ".."
                    if (length(img_tag) > 8) img_tag = substr(img_tag, 1, 6) ".."
                    image = img_name ":" img_tag
                } else {
                    if (length(image) > 20) image = substr(image, 1, 18) ".."
                }

                # Pad name manually to handle ANSI colors correctly
                padded_name = sprintf("%-18s", name)
                printf "%s%s%s %-4s %s%-2s%s %-4s %s%-12s%s %s\n",
                    ccolor, padded_name, reset,
                    state_display,
                    hcolor, health, reset,
                    uptime,
                    cyan, port_display, reset,
                    image
            }
        }'
}

# Show logs
show_logs() {
    local stack="${1:-}"
    local tail="${2:-100}"
    local follow="${3:-false}"

    if [ -n "$stack" ]; then
        print_info "Showing logs for ${stack} stack..."
        if [ "$stack" = "root" ]; then
            if [ "$follow" = "true" ]; then
                cd "${ROOT_DIR}" && docker compose logs --tail "$tail" -f
            else
                cd "${ROOT_DIR}" && docker compose logs --tail "$tail"
            fi
        else
            if [ -d "${STACKS_DIR}/${stack}" ]; then
                if [ "$follow" = "true" ]; then
                    cd "${STACKS_DIR}/${stack}" && docker compose logs --tail "$tail" -f
                else
                    cd "${STACKS_DIR}/${stack}" && docker compose logs --tail "$tail"
                fi
            else
                print_error "Stack '${stack}' not found"
                return 1
            fi
        fi
    else
        print_info "Showing logs for all stacks..."

        if [ -f "${ROOT_DIR}/compose.yaml" ]; then
            cd "${ROOT_DIR}" && docker compose logs --tail "$tail"
        fi

        while IFS= read -r stack; do
            if [ -f "${STACKS_DIR}/${stack}/compose.yaml" ]; then
                cd "${STACKS_DIR}/${stack}" && docker compose logs --tail "$tail"
            fi
        done < <(get_stacks)
    fi
}

# Pull images
pull_images() {
    print_info "Pulling latest images..."

    if [ -f "${ROOT_DIR}/compose.yaml" ]; then
        cd "${ROOT_DIR}" && docker compose pull
    fi

    while IFS= read -r stack; do
        if [ -f "${STACKS_DIR}/${stack}/compose.yaml" ]; then
            echo "Pulling ${stack}..."
            cd "${STACKS_DIR}/${stack}" && docker compose pull
        fi
    done < <(get_stacks)

    print_success "Pull complete"
}

# Update containers
update_containers() {
    print_info "Updating all containers..."

    if [ -f "${ROOT_DIR}/compose.yaml" ]; then
        cd "${ROOT_DIR}" && docker compose pull && docker compose up -d
    fi

    while IFS= read -r stack; do
        if [ -f "${STACKS_DIR}/${stack}/compose.yaml" ]; then
            echo "Updating ${stack}..."
            cd "${STACKS_DIR}/${stack}" && docker compose pull && docker compose up -d
        fi
    done < <(get_stacks)

    print_success "Update complete"
}

# Clean up Docker resources
clean_docker() {
    print_info "Cleaning up Docker resources..."
    docker system prune -f
    print_success "Cleanup complete"
}

# Format README
format_readme() {
    print_info "Updating README.md with service listings..."

    if [ ! -f "${SCRIPTS_DIR}/update-readme.py" ]; then
        print_error "Error: update-readme.py not found"
        return 1
    fi

    # Use venv python if available, otherwise fall back to python3
    local python_cmd="python3"
    if [ -f "${ROOT_DIR}/.venv/bin/python" ]; then
        python_cmd="${ROOT_DIR}/.venv/bin/python"
    fi

    "$python_cmd" "${SCRIPTS_DIR}/update-readme.py"
    print_success "README.md updated successfully"
}

# Build custom images
build_images() {
    print_info "Building custom images..."

    while IFS= read -r stack; do
        if [ -f "${STACKS_DIR}/${stack}/compose.yaml" ]; then
            echo "Checking ${stack} for buildable images..."
            cd "${STACKS_DIR}/${stack}" && docker compose build 2>/dev/null || true
        fi
    done < <(get_stacks)

    print_success "Build complete"
}

# Create backup
create_backup() {
    print_info "Creating backup..."

    mkdir -p "${ROOT_DIR}/backups"
    local backup_file="backups/nexus-backup-$(date +%Y%m%d-%H%M%S).tar.gz"

    cd "${ROOT_DIR}"
    tar -czf "$backup_file" \
        --exclude='backups' \
        --exclude='.git' \
        --exclude='*/data' \
        stacks/ compose.yaml .env 2>/dev/null || true

    print_success "Backup created: ${backup_file}"
}

# Validate compose files
validate_compose() {
    print_info "Validating compose files..."

    local errors=0

    while IFS= read -r stack; do
        if [ -f "${STACKS_DIR}/${stack}/compose.yaml" ]; then
            echo "Validating ${stack}..."
            if ! docker compose -f "${STACKS_DIR}/${stack}/compose.yaml" config > /dev/null 2>&1; then
                print_error "Validation failed for ${stack}"
                ((errors++))
            fi
        fi
    done < <(get_stacks)

    if [ $errors -eq 0 ]; then
        print_success "All compose files are valid"
    else
        print_error "Validation failed for $errors stack(s)"
        return 1
    fi
}

# Show help
show_help() {
    cat << 'EOF'
Nexus CLI - Docker Stack Management Tool

Usage: nx <command> [options]

COMMANDS:
EOF

    # Dynamically generate command list from annotations
    echo "  Setup & Configuration:"
    grep -E "^\s+# @completion (check|deps|setup|list|services|interactive) " "$0" | while IFS= read -r line; do
        if [[ $line =~ @completion\ ([a-z-]+)\ (.+)$ ]]; then
            printf "    %-20s %s\n" "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
        fi
    done

    echo ""
    echo "  Stack Management:"
    grep -E "^\s+# @completion (start|stop|restart|status|logs) " "$0" | while IFS= read -r line; do
        if [[ $line =~ @completion\ ([a-z-]+)\ (.+)$ ]]; then
            printf "    %-20s %s\n" "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
        fi
    done

    echo ""
    echo "  Maintenance:"
    grep -E "^\s+# @completion (pull|update|clean|fmt|build|backup|validate) " "$0" | while IFS= read -r line; do
        if [[ $line =~ @completion\ ([a-z-]+)\ (.+)$ ]]; then
            printf "    %-20s %s\n" "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
        fi
    done

    echo ""
    echo "  General:"
    grep -E "^\s+# @completion (help|version) " "$0" | while IFS= read -r line; do
        if [[ $line =~ @completion\ ([a-z-]+)\ (.+)$ ]]; then
            printf "    %-20s %s\n" "${BASH_REMATCH[1]}" "${BASH_REMATCH[2]}"
        fi
    done

    cat << 'EOF'

OPTIONS:
  --install           (with check) Attempt to install missing prerequisites
  -f, --follow        (with logs) Follow log output

STACK COMMANDS:
  nx <stack> <args>     Run docker compose commands directly on a stack
                        Available stacks: app, core, data, log, media

EXAMPLES:
  nx check              # Check if all prerequisites are installed
  nx check --install    # Check and install missing prerequisites
  nx list               # Show stack overview with service count
  nx list -v            # Show detailed stack information
  nx services           # List all services with their status (alphabetical)
  nx services --stacks  # List services grouped by stack
  nx services prometheus # Filter services containing 'prometheus'
  nx services --stacks prom # Group by stack and filter for 'prom'
  nx interactive        # Enter interactive mode to toggle services
  nx i traefik          # Interactive mode filtering for 'traefik'
  nx start              # Start all services
  nx stop               # Stop all services
  nx restart            # Restart all services
  nx logs -f            # Follow logs for all services
  nx status             # Show container status with health
  nx status -w          # Watch container status with auto-refresh
  nx update             # Update all containers
  nx fmt                # Update README

For more information, visit: https://github.com/jovalle/nexus
EOF
}

# Show version
show_version() {
    echo "Nexus CLI v1.0.0"
    echo "Repository: https://github.com/jovalle/nexus"
}

# Main command dispatcher
main() {
    local command="${1:-help}"
    shift || true

    case "$command" in
        # @completion deps Check prerequisites (optionally install missing ones)
        # @arg --install Attempt to install missing prerequisites
        deps)
            if [[ "${1:-}" == "--install" ]]; then
                check_prerequisites "true"
            else
                check_prerequisites "false"
            fi
            ;;
        # @completion setup Run initial setup (install brew, make, etc.)
        setup)
            setup
            ;;
        # @completion check Validate environment, security, and permissions
        check)
            check
            ;;
        # @completion list Show stack overview and service count
        # @arg -v,--verbose Show detailed information with running services
        list)
            if [[ "${1:-}" == "-v" || "${1:-}" == "--verbose" ]]; then
                list_stacks "true"
            else
                list_stacks "false"
            fi
            ;;
        # @completion services List all services with their status
        # @arg --stacks Group services by stack (homepage.group label)
        # @arg [filter] Optional filter to match service names
        services)
            list_services "$@"
            ;;
        # @completion interactive Interactive mode to toggle services
        # @arg [filter] Optional filter to match service names
        interactive|i)
            interactive_mode "${1:-}"
            ;;
        # @completion start Start all stacks or a specific stack
        # @arg [stack] Stack name to start
        start)
            start_stacks "${1:-}"
            ;;
        # @completion stop Stop all stacks or a specific stack
        # @arg [stack] Stack name to stop
        stop)
            stop_stacks "${1:-}"
            ;;
        # @completion restart Restart all stacks or a specific stack
        # @arg [stack] Stack name to restart
        restart)
            restart_stacks "${1:-}"
            ;;
        # @completion status Show container status with health for a stack
        # @arg [stack] Stack name to show status for (shows all if omitted)
        # @arg -w,--watch Watch mode with auto-refresh
        status)
            local stack="${1:-}"
            local watch_mode="false"
            if [[ "${2:-}" == "-w" || "${2:-}" == "--watch" ]]; then
                watch_mode="true"
            fi
            if [ -n "$stack" ] && [ "$stack" != "root" ] && [ ! -d "${STACKS_DIR}/${stack}" ]; then
                print_error "Stack '${stack}' not found"
                exit 1
            fi
            if [ "$watch_mode" = "true" ]; then
                local compact="true"
                watch -c -n 1 -d -t "$(declare -f show_status); show_status '$stack' '$compact'"
            else
                show_status "$stack" "false"
            fi
            ;;
        # @completion logs Show logs (optionally follow with -f)
        # @arg [stack] Stack name to show logs for
        # @arg -f,--follow Follow log output
        logs)
            local stack="${1:-}"
            local follow="false"
            if [[ "${2:-}" == "-f" || "${2:-}" == "--follow" ]]; then
                follow="true"
            fi
            show_logs "$stack" "100" "$follow"
            ;;
        # @completion pull Pull latest images for all stacks
        pull)
            pull_images
            ;;
        # @completion update Update all containers to latest versions
        update)
            update_containers
            ;;
        # @completion clean Remove stopped containers and unused images
        clean)
            clean_docker
            ;;
        # @completion fmt Update README.md with latest service listings
        fmt)
            format_readme
            ;;
        # @completion build Build custom images (if any)
        build)
            build_images
            ;;
        # @completion backup Create backup of all stack configurations
        backup)
            create_backup
            ;;
        # @completion validate Validate all compose files
        validate)
            validate_compose
            ;;
        # @completion help Show this help message
        help|--help|-h)
            show_help
            ;;
        # @completion version Show version information
        version|--version|-v)
            show_version
            ;;
        # Stack-specific wildcard commands (e.g., nx app up -d, nx core logs -f)
        app|core|data|log|media)
            local stack="$command"
            if [ -d "${STACKS_DIR}/${stack}" ]; then
                cd "${STACKS_DIR}/${stack}"
                if [ $# -gt 0 ]; then
                    docker compose "$@"
                else
                    print_error "No docker compose command provided"
                    echo "Usage: nx ${stack} <docker-compose-command> [args...]"
                    echo "Example: nx ${stack} up -d"
                    exit 1
                fi
            else
                print_error "Stack '${stack}' not found"
                exit 1
            fi
            ;;
        *)
            print_error "Unknown command: $command"
            echo ""
            echo "Run 'nx help' for usage information"
            exit 1
            ;;
    esac
}

# Run main function
main "$@"
